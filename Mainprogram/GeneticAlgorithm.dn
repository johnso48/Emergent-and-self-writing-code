const char DEFAULT_SERVER_IP[] = "localhost"
const int DEFAULT_SERVER_PORT = 8008

const int ITERATION_COUNT = 3
const int STAT_INTERVAL = 5000

uses pal.control.RestAPI
uses tree.treeConstructor
component provides GeneticAlgorithm requires webDriver, io.Output out, data.IntUtil iu, data.StringUtil stringUtil, Knowledge.KnowledgeBase, util.RandomInt ri, time.DateUtil du, time.Calendar cal{

	webDriver drive
	
	int firstBest
	int secondBest
	int firstBestIndex
	int secondBestIndex
	char[] GeneticAlgorithm:call(RestAPI restAPI, interfaceLevels interfaces[], KnowledgeBase kb)
	{
		firstBest = 99999999999
		firstBestIndex = 0
		secondBest = 99999999999
		secondBestIndex = 0
		drive = new webDriver(restAPI)
		Children child[] = new Children[5]
		out.println("GATest")
		ri.setSeed(du.toMilliseconds(cal.getTime()))
		for (int i = 0; i < 5; i++)
		{
			child[i] = new Children()
			int ranNum = ri.get(interfaces[0].componentNames.arrayLength)
			String empty[] = new String[1]
			empty[0] = new String("")
			child[i].config = getConfigParts(interfaces[0].componentNames[ranNum].string, interfaces[0].interfaceName, interfaces, empty)
			child[i].fitness = kb.testNewConfig(drive.getConfig(child[i].config))
		}
		
		for (int i = 0; i < 5; i++)
		{
			if (child[i].fitness < firstBest)
			{
				secondBest = firstBest
				secondBestIndex = firstBestIndex
				firstBest = child[i].fitness
				firstBestIndex = i	
			}else{
				if (child[i].fitness < secondBest)
				secondBest = child[i].fitness
				secondBestIndex = i
			}
		}
		
		char bestConfig[] = breed(child[firstBestIndex], child[secondBestIndex])
		
		
		return null
	}
	
	char[] breed (Children parent1, Children parent2)
	{
		Children child[] = new Children[5]
		int randomNum
		for (int i = 0; i< 5; i++)
		{
			char newConfig[]
			randomNum = ri.get(2)
			if (randomNum == 0){
				newConfig = parent1.config[0].string
				out.println(newConfig)
			}else
			{
				newConfig = parent2.config[0].string
				out.println(newConfig)
			}
			
		}
		return null
	}
	
	
	String[] getConfigParts(char componentName[], char interfaceName[], interfaceLevels interfaces[], String currentConfig[])
		{
			String part[]
			for(int i = 0; i < interfaces.arrayLength; i++)
			{
				if (interfaces[i].interfaceName == interfaceName)
				{
					for (int j = 0; j < interfaces[i].componentNames.arrayLength; j++)
					{
						if (interfaces[i].componentNames[j].string == componentName)
						{
							if (interfaces[i].requirements[j].string == "-")
							{
								String returnComponent[] = new String[1]
								returnComponent[0] = new String()
								returnComponent[0].string = componentName
								return returnComponent
							}else
							{
								String subInterfaceNames[] = stringUtil.explode(interfaces[i].requirements[j].string, ",")
								int numOfSubParts = 0
								for (int k = 0; k < subInterfaceNames.arrayLength; k++)
								{
									numOfSubParts = numOfSubParts + getSubParts(subInterfaceNames[k].string, interfaces, currentConfig).arrayLength
								}
								part = new String[numOfSubParts + 1]
								for (int k = 0; k < part.arrayLength; k++)
								{
									part[k] = new String()
									part[k].string = "-"
								}
								
								part[0].string = componentName
								for (int k = 0; k < subInterfaceNames.arrayLength; k++)
								{
									String subParts[] = getSubParts(subInterfaceNames[k].string, interfaces, currentConfig)
									int l = 1
									while (part[l].string != "-")
									{
										l++
										
									}
									for (int m = 0; m < subParts.arrayLength; m++)
									{
										part[l] = subParts[m]
										l++
									}
								}
								return part
							}
						}
					}
				}
			}
			
			String default[] = new String[1]
			default[0] = new String("-")
			return default
		}
		
	String[] getSubParts(char interfaceName[], interfaceLevels interfaces[], String currentConfig[])
		{
			
			int randomNum
			String parts[]
			bool inList = 0
			char componentName[]
			
			int indexNum
			for (int i = 0; i < interfaces.arrayLength; i++)
			{
				if (interfaces[i].interfaceName == interfaceName)
				{
					for (int j = 0; j < interfaces[i].componentNames.arrayLength; j++)
					{
						for (int k = 0; k < currentConfig.arrayLength; k++)
						{
							if (interfaces[i].componentNames[j].string == currentConfig[k].string)
							{
								inList = 1
								componentName = currentConfig[k].string
								indexNum = j
							}
						}
					}
					if (!inList)
					{
						randomNum = ri.get(interfaces[i].componentNames.arrayLength)
						if (interfaces[i].requirements[randomNum].string == "-")
						{
							parts = new String[1]
							parts[0] = interfaces[i].componentNames[0]
							return parts
						}else
						{
							String subInterfaceNames[] = stringUtil.explode(interfaces[i].requirements[0].string, ",")

							int numOfSubParts = 0
							for (int j = 0; j < subInterfaceNames.arrayLength; j++)
							{
								numOfSubParts = numOfSubParts + getSubParts(subInterfaceNames[j].string, interfaces, currentConfig).arrayLength	
							}
							parts = new String[numOfSubParts + 1]
							for (int j = 0; j < parts.arrayLength; j++)
							{
								parts[j] = new String("-")
							}
							parts[0] = interfaces[i].componentNames[randomNum]
							for (int j = 0; j < subInterfaceNames.arrayLength; j++)
							{
								String subParts[] = getSubParts(subInterfaceNames[j].string, interfaces, currentConfig)
								int l = 1
								while (parts[l].string != "-")
								{
									l++
								}
								for (int k = 0; k < subParts.arrayLength; k++)
								{
									parts[l] = subParts[k]
									l++
								}
							}
							return parts
						}
					
					}else
					{
												
						if (interfaces[i].requirements[indexNum].string == "-")
						{
							parts = new String[1]
							parts[0] = interfaces[i].componentNames[0]
							return parts
						}else
						{
							String subInterfaceNames[] = stringUtil.explode(interfaces[i].requirements[0].string, ",")

							int numOfSubParts = 0
							for (int j = 0; j < subInterfaceNames.arrayLength; j++)
							{
								numOfSubParts = numOfSubParts + getSubParts(subInterfaceNames[j].string, interfaces, currentConfig).arrayLength	
							}
							parts = new String[numOfSubParts + 1]
							for (int j = 0; j < parts.arrayLength; j++)
							{
								parts[j] = new String("-")
							}
							parts[0] = interfaces[i].componentNames[indexNum]
							for (int j = 0; j < subInterfaceNames.arrayLength; j++)
							{
								String subParts[] = getSubParts(subInterfaceNames[j].string, interfaces, currentConfig)
								int l = 1
								while (parts[l].string != "-"){
									l++
								}
								for (int k = 0; k < subParts.arrayLength; k++)
								{
									parts[l] = subParts[k]
									l++
								}
							}
							return parts
						}
					}
				}
			}
			String default[] = new String[1]
			default[0] = new String("-")
			return default
			
		}
		
}